---
title: "Intersectional climate justice perspective: The case of extreme heat in Erie County, NY."
author: Enoch Yeleliere
format: hmtl
---

# Introduction

The rise in global temperatures above pre-industrial levels, coupled with rapid urbanization—projected to exceed 70% by 2050 (UN DESA, 2018)—has led to increased greenhouse gas emissions, exacerbating the Urban Heat Effect (UHE) (Jung et al., 2024). This phenomenon has made summers increasingly difficult, especially in parts of the United States (US), with profound socio-ecological impacts and disruptions. The escalation of extreme heat has created significant environmental and social challenges, raising critical concerns related to environmental and climate justice (Mitchell and Chakraborty, 2014). Heatwaves not only contribute to health complications—such as respiratory and cardiovascular issues—but also degrade urban environmental quality, diminishing residents' overall quality of life (Li et al., 2019). These changes are further evidenced by increased electricity consumption during the summer months, as residents rely on air conditioning to mitigate heat risks. However, this reliance creates additional challenges, including disparities in access to cooling systems for vulnerable groups and a 19% rise in energy consumption, leading to higher electricity costs for residents (Li et al., 2019).

Urban areas with limited urban green infrastructure (UGI) are particularly susceptible to heat risks, as the absence of green spaces correlates with poor air quality and reduced cooling effects (Chen, 2024; Wilby, 2008). While much research has focused on the Urban Heat Island (UHI) effect, often through a climate or environmental justice lens, fewer studies explore the intersectional dimensions of climate justice. Such an intersectional approach integrates factors like surface temperature, socio-demographic characteristics, and the presence of UGI to better understand how vulnerability to heat risk varies across different communities.

This perspective is particularly relevant given the history of systemic discrimination in US cities, where practices like redlining have reduced green infrastructure in minority neighborhoods and intensified racial segregation. In this context, the study addresses the following research questions:

i)  What are the spatial patterns of heat risk in Erie County, New York?

ii) How do socio-demographic, economic, and spatial factors intersect to shape the vulnerability of different groups?

# Materials and methods

The study used multiple data sources to examine the socioeconomic features of census tracts including the cloud-free 30-m-resolution Landsat 8 satellite from the United States Geological Survey (USGS), surface temperature (APPEARS), and 5-year estimate American Community Survey (ACS) provided by the US Census Bureau (<https://www.census.gov/>) or Tidy census.

The study employs spatial regression analysis to investigate the relationship between heat risk—measured by land surface temperature—and the presence of racial minorities, low-income residents, and elderly populations. Additionally, the study identifies variations in spatial pattern variables among these vulnerable groups, categorizing them as low, medium, or high risk. Census tracts with a z-score greater than 1 are classified as “high risk,” those with a z-score lower than -1 are classified as “low risk,” while the remaining tracts are designated as “medium risk.” Subsequently, the study utilizes analysis of variance (ANOVA) to assess the significance of spatial pattern variations among these groups and examines how these disparities contribute to heat inequity.

#Load required packages:

```{r, message=F, warning=F}
library(tidyverse)
library(tidycensus)
library(leaflet)
library(dplyr)         # For data manipulation
library(tidyverse)
library(terra)
library(sf)
library(leaflet)        # For interactive maps
library(ggplot2)        # For ggplot2 plotting
library(rasterVis)      # For raster visualization
```

## Download, clean, and process data (Landsat 8 collective 2 level 1)

```{r}

# Load Erie County shapefile (adjust path as necessary)
erie_shapefile <- "data/erie.shp"
erie_county <- st_read(erie_shapefile)

# Load Landsat 8 raster files (adjust directory as necessary)
tif_files <- list.files("data", pattern = "\\.TIF$", full.names = TRUE)

# Load the rasters using terra::rast
rasters <- lapply(tif_files, rast)

# Check the extents, resolutions, and CRS of each raster
extents <- lapply(rasters, ext)
resolutions <- lapply(rasters, res)
crs_list <- lapply(rasters, crs)

# Find the common extent by intersecting the extents of all rasters
common_extent <- Reduce(intersect, extents)  # Finds the common extent

# Print the common extent
print(common_extent)

# Find the common resolution (assume the first raster resolution)
common_res <- res(rasters[[1]])

# Ensure the same CRS for all rasters
reference_crs <- crs(rasters[[1]])
rasters <- lapply(rasters, function(r) {
  if (!identical(crs(r), reference_crs)) {
    project(r, reference_crs)
  } else {
    r
  }
})

# Crop and resample the rasters to the common extent and resolution
rasters_aligned <- lapply(rasters, function(r) {
  r_resampled <- resample(crop(r, common_extent), rast(extent = common_extent, res = common_res, crs = reference_crs))
  return(r_resampled)
})

# Create a raster stack from the aligned rasters
raster_stack <- rast(rasters_aligned)

# Ensure the boundary is in the same CRS as the raster stack
if (crs(raster_stack) != st_crs(erie_county)) {
  erie_county <- st_transform(erie_county, crs(raster_stack))
}

# Convert the Erie County boundary shapefile to a 'SpatVector' for raster operations
erie_boundary_vect <- vect(erie_county)

# Crop the raster stack using the Erie County boundary
raster_cropped <- crop(raster_stack, erie_boundary_vect)

# Plot the cropped raster (first 12 bands)
plot(raster_cropped[[1:12]], main = "First 12 Bands of the Cropped Raster")

# Compute the mean temperature across the first 12 bands of the raster stack
temperature_stack <- raster_cropped[[1:12]]
mean_temperature <- app(temperature_stack, fun = mean, na.rm = TRUE)

# Plot the mean temperature
plot(mean_temperature, main = "Mean Temperature (First 12 Bands)")

# Ensure the CRS of the mean temperature raster matches the Erie County shapefile
if (crs(mean_temperature) != st_crs(erie_county)) {
  erie_county <- st_transform(erie_county, crs(mean_temperature))
}
```

```{r}

#Plot temperature intensity using color intensity from raster_cropped

plotRGB(raster_stack, stretch="lin")
plotRGB(raster_cropped, stretch="lin") # Linear stretch


plotRGB(raster_stack, stretch="hist")
plotRGB(raster_cropped, stretch="hist") # Histogram equalization stretch

```


```{r}
# Define a color palette for the temperature plot
temperature_palette <- terrain.colors(100)

# Plot the mean temperature with the Erie County boundary overlay
plot(mean_temperature, col = temperature_palette, main = "Mean Surface Temperature in Erie County, NY")
```




```{r}
# Perform hotspot analysis based on the 90th percentile of temperature values
# Calculate the 90th percentile of the temperature values
temperature_values <- values(mean_temperature)
percentile_90 <- quantile(temperature_values, 0.90, na.rm = TRUE)

# Create a binary hotspot layer: 1 for pixels above the 90th percentile, 0 otherwise
hotspot_layer <- mean_temperature >= percentile_90

# Plot the hotspot layer
plot(hotspot_layer, main = "Surface Temperature Hotspots in Erie County")
```




```{r}
# Crop raster stack using Erie County boundary
raster_cropped <- crop(raster_stack, erie_boundary_vect)

# Extract required bands for indices
red <- raster_cropped[[4]]     # Band 4: Red
nir <- raster_cropped[[5]]     # Band 5: Near-Infrared (NIR)
swir1 <- raster_cropped[[6]]   # Band 6: Shortwave Infrared 1 (SWIR1)
tir <- raster_cropped[[10]]    # Band 10: Thermal Infrared (TIR)

# Calculate NDVI
ndvi <- (nir - red) / (nir + red)

# Calculate NDBI
ndbi <- (swir1 - nir) / (swir1 + nir)

# Calculate LST
radiance <- tir * 0.0003342 + 0.1  # Conversion to radiance (use constants from metadata)
kelvin_temp <- 1321.08 / log((774.89 / radiance) + 1)  # Convert radiance to temperature in Kelvin
lst <- kelvin_temp - 273.15  # Convert Kelvin to Celsius

# Calculate UHRI
uhri <- (lst + ndbi) - ndvi
```

```{r}

# Set up the 2x2 plot layout
par(mfrow = c(2, 2))

# Bright color palettes for each index
ndvi_palette <- colorRampPalette(c("red", "yellow", "green"))(100)
ndbi_palette <- colorRampPalette(c("white", "blue", "black"))(100)  # Example for NDBI
lst_palette <- colorRampPalette(c("white", "blue", "red"))(100)  # Example for LST
uhri_palette <- colorRampPalette(c("white", "orange", "purple"))(100)  # Example for UHRI

# Plot NDVI with bright colors
plot(ndvi, main = "NDVI", col = ndvi_palette, legend = TRUE)

# Plot NDBI with bright colors
plot(ndbi, main = "NDBI", col = ndbi_palette, legend = TRUE)

# Plot LST with bright colors
plot(lst, main = "LST (°C)", col = lst_palette, legend = TRUE)

# Plot UHRI with bright colors
plot(uhri, main = "UHRI", col = uhri_palette, legend = TRUE)


```

#Alternative colors
```{r}
# Set up color palettes
ndvi_palette <- colorRampPalette(c("#048C02", "#77DD77", "#B5E7A0", "#D6E9C6"))
ndbi_palette <- colorRampPalette(c("#F5F5F5", "#A9A9A9", "#696969", "#000000"))
lst_palette <- colorRampPalette(c("#FFCCCB", "#FF7F50", "#FF4500", "#B22222"))
uhri_palette <- colorRampPalette(c("#4575B4", "#91BFDB", "#FEE090", "#FC8D59", "#D73027"))

# Plot results
par(mfrow = c(2, 2))  # Arrange plots in 2x2 grid

# Plot NDVI
plot(ndvi, col = ndvi_palette(100), main = "NDVI", axes = FALSE)
box()

# Plot NDBI
plot(ndbi, col = ndbi_palette(100), main = "NDBI", axes = FALSE)
box()

# Plot LST
plot(lst, col = lst_palette(100), main = "LST (°C)", axes = FALSE)
box()

# Plot UHRI
plot(uhri, col = uhri_palette(100), main = "UHRI", axes = FALSE)
box()

```




#Prepare census data for socio-demographic characteristics
```{r}
# Set your census API key (Replace with your key)
census_api_key("677c6e6ec5f3c8621d7b139013d29cb61cf4dcdd", overwrite = TRUE, install = TRUE)

```


#Download Block level census data
#Race
```{r}
# Define the race variables
race_vars <- c(
  "Total Population" = "P1_001N",
  "White alone" = "P1_003N",
  "Black or African American alone" = "P1_004N",
  "American Indian and Alaska Native alone" = "P1_005N",
  "Asian alone" = "P1_006N",
  "Native Hawaiian and Other Pacific Islander alone" = "P1_007N",
  "Some Other Race alone" = "P1_008N",
  "Two or More Races" = "P1_009N"
)


```


#Age
```{r}
# Define the age variables
age_vars <- c(
  "Total Population" = "P1_001N",
  "Under 5 years" = "P1_003N",
  "5 to 9 years" = "P1_004N",
  "10 to 14 years" = "P1_005N",
  "15 to 19 years" = "P1_006N",
  "20 to 24 years" = "P1_007N",
  "25 to 34 years" = "P1_008N",
  "35 to 44 years" = "P1_009N",
  "45 to 54 years" = "P1_010N",
  "55 to 64 years" = "P1_011N",
  "65 to 74 years" = "P1_012N",
  "75 to 84 years" = "P1_013N",
  "85 years and over" = "P1_014N"
)

```




```{r}
# Get census data for race, age, and income
options(tigris_use_cache = TRUE)

# Download race data
erie_race <- get_decennial(geography = "block", variables = race_vars, year=2020,
                           state = "NY", county = "Erie County", geometry = TRUE,
                           sumfile = "pl", cache_table = TRUE)

# Download age data
erie_age <- get_decennial(geography = "block", variables = age_vars, year=2020,
                           state = "NY", county = "Erie County", geometry = TRUE,
                           sumfile = "pl", cache_table = TRUE)

```
#Analysis
```{r}
# Join temperature data with the census data for blocks
# First, extract the values from the hotspot_layer to match spatially with the census data
hotspot_values <- extract(hotspot_layer, erie_race)

# Convert the hotspot data to a data frame for merging
hotspot_df <- data.frame(block_id = erie_race$GEOID, hotspot = hotspot_values)

# Merge with the census race data
census_race_data <- merge(erie_race, hotspot_df, by = "block_id")

# Now you can analyze relationships between surface temperature hotspots and race, age, etc.
# For example, you could use ggplot to visualize the relationship
ggplot(census_race_data) +
  geom_sf(aes(fill = hotspot)) +
  scale_fill_manual(values = c("0" = "white", "1" = "red")) +
  theme_minimal() +
  labs(title = "Surface Temperature Hotspots in Erie County by Race")

```

```{r}
# Plot RGB composite (e.g., Red, Green, Blue using Bands 4, 3, 2)
plotRGB(raster_stack, r = 4, g = 3, b = 2, main = "True Color Composite")

# Plot the first few bands
par(mfrow = c(4, 4))  # Arrange the plot into a 4x4 grid
for (i in 1:12) {
  plot(raster_stack[[i]], main = paste("Band", i))
}
```


## Prepare census data for socio-demographic characteristics

```{r}
library(tidycensus)
census_api_key("677c6e6ec5f3c8621d7b139013d29cb61cf4dcdd", overwrite = TRUE, install = TRUE)
```

```{r}
#download block data
# Define the race variables
race_vars <- c(
  "Total Population" = "P1_001N",
  "White alone" = "P1_003N",
  "Black or African American alone" = "P1_004N",
  "American Indian and Alaska Native alone" = "P1_005N",
  "Asian alone" = "P1_006N",
  "Native Hawaiian and Other Pacific Islander alone" = "P1_007N",
  "Some Other Race alone" = "P1_008N",
  "Two or More Races" = "P1_009N"
)
```

```{r}
# Get census data for race
options(tigris_use_cache = TRUE)
erie_race <- get_decennial(geography = "block", variables = race_vars, year=2020,
                  state = "NY", county = "Erie County", geometry = TRUE,
                  sumfile = "pl", 
                  cache_table=T) 
```

```{r}
erie_county<-sf_read("data"/Erie_County.shp)
```

```{r}
age_vars <- c(
  "Total Population" = "P1_001N",
  "Under 5 years" = "P1_003N",
  "5 to 9 years" = "P1_004N",
  "10 to 14 years" = "P1_005N",
  "15 to 19 years" = "P1_006N",
  "20 to 24 years" = "P1_007N",
  "25 to 34 years" = "P1_008N",
  "35 to 44 years" = "P1_009N",
  "45 to 54 years" = "P1_010N",
  "55 to 64 years" = "P1_011N",
  "65 to 74 years" = "P1_012N",
  "75 to 84 years" = "P1_013N",
  "85 years and over" = "P1_014N"
)
```

```{r}
# Get census data for age
options(tigris_use_cache = TRUE)
erie_age <- get_decennial(geography = "block", variables = age_vars, year = 2020,
                          state = "NY", county = "Erie County", geometry = TRUE,
                          sumfile = "pl", cache_table = TRUE)
```

```{r}
income_vars <- c(
  "Total Households" = "B19001_001",
  "Less than $10,000" = "B19001_002",
  "$10,000 to $14,999" = "B19001_003",
  "$15,000 to $19,999" = "B19001_004",
  "$20,000 to $24,999" = "B19001_005",
  "$25,000 to $29,999" = "B19001_006",
  "$30,000 to $34,999" = "B19001_007",
  "$35,000 to $39,999" = "B19001_008",
  "$40,000 to $44,999" = "B19001_009",
  "$45,000 to $49,999" = "B19001_010",
  "$50,000 to $59,999" = "B19001_011",
  "$60,000 to $74,999" = "B19001_012",
  "$75,000 to $99,999" = "B19001_013",
  "$100,000 to $124,999" = "B19001_014",
  "$125,000 to $149,999" = "B19001_015",
  "$150,000 to $199,999" = "B19001_016",
  "$200,000 or more" = "B19001_017"
)
```

```{r}
# Define your income variable (e.g., B19001_001 for total household income)
income_vars <- c("B19001_001")
# Query ACS 5-year estimates at the Block Group level (since block-level data isn't available)
erie_income <- get_acs(
  geography = "block group",  # Change from block to block group or tract
  variables = income_vars,
  year = 2021,  # 5-year estimates for 2021
  state = "NY",  # New York State
  county = "Erie",  # Erie County
  geometry = TRUE  # Include geometry (spatial data)
)
```

##Combine socio-demographic data

```{r}
# Perform sequential spatial joins 
race_age_data <- st_join(erie_race, erie_age) 
combined_data <- st_join(race_age_data, erie_income)
```

```{r}
# define census region using a spatial bounding box and rasterize data
bbox<-st_bbox(erie_race, erie_age, erie_income)
domain <- raster(resolution=0.008,crs=projection(erie_race),               xmn=bbox$xmin,xmx=bbox$xmax,ymn=bbox$ymin,ymx=bbox$ymax)
```

```{r}
n=20
data=data.frame(x=runif(n,-180,180),
                y=runif(n,-60,60),
                size = runif(n, 5, 20),
                category = factor(
                  sample(letters[1:5], n, replace = TRUE)
                  ),
                value = rnorm(n))
```

```{r, results='asis'}
data %>% 
  slice(1:10) %>% #show only 1:n rows
  kable(digits=2,align="c")%>% #make table and round to two digits
  kable_styling(bootstrap_options = 
                  c("striped", "hover", "condensed", "responsive")) #apply other formatting
```

Add any additional processing steps here.

# Results

\[\~200 words\]

Tables and figures (maps and other graphics) are carefully planned to convey the results of your analysis. Intense exploration and evidence of many trials and failures. The author looked at the data in many different ways before coming to the final presentation of the data.

Show tables, plots, etc. and describe them.

```{r, fig.width=6, fig.height=3, fig.cap="Map of completely random data"}
m <- leaflet(data) %>% 
  addTiles() %>% 
  addCircleMarkers(~x, ~y, radius = ~size,color = ~as.factor(category)) %>% 
  addPopups(~x[2], ~y[2], "Random popup")
m  # a map with the default OSM tile layer
```

```{r}
data %>% 
  ggplot(aes(x=x,y=y,col=category))+
  geom_point()
```

# Conclusions

\[\~200 words\]

Clear summary adequately describing the results and putting them in context. Discussion of further questions and ways to continue investigation.

# References

All sources are cited in a consistent manner
