---
title: "Intersectional climate justice perspective: The case of extreme heat in Erie County, NY."
author: Enoch Yeleliere
format: hmtl
---

# Introduction

The rise in global temperatures above pre-industrial levels, coupled with rapid urbanization—projected to exceed 70% by 2050 (UN DESA, 2018)—has led to increased greenhouse gas emissions, exacerbating the Urban Heat Effect (UHE) (Jung et al., 2024). This phenomenon has made summers increasingly difficult, especially in parts of the United States (US), with profound socio-ecological impacts and disruptions. The escalation of extreme heat has created significant environmental and social challenges, raising critical concerns related to environmental and climate justice (Mitchell and Chakraborty, 2014). Heatwaves not only contribute to health complications—such as respiratory and cardiovascular issues—but also degrade urban environmental quality, diminishing residents' overall quality of life (Li et al., 2019). These changes are further evidenced by increased electricity consumption during the summer months, as residents rely on air conditioning to mitigate heat risks. However, this reliance creates additional challenges, including disparities in access to cooling systems for vulnerable groups and a 19% rise in energy consumption, leading to higher electricity costs for residents (Li et al., 2019).

Urban areas with limited urban green infrastructure (UGI) are particularly susceptible to heat risks, as the absence of green spaces correlates with poor air quality and reduced cooling effects (Chen, 2024; Wilby, 2008). While much research has focused on the Urban Heat Island (UHI) effect, often through a climate or environmental justice lens, fewer studies explore the intersectional dimensions of climate justice. Such an intersectional approach integrates factors like surface temperature, socio-demographic characteristics, and the presence of UGI to better understand how vulnerability to heat risk varies across different communities.

This perspective is particularly relevant given the history of systemic discrimination in US cities, where practices like redlining have reduced green infrastructure in minority neighborhoods and intensified racial segregation. In this context, the study addresses the following research questions:

i)  What are the spatial patterns of heat risk in Erie County, New York?

ii) How do socio-demographic, economic, and spatial factors intersect to shape the vulnerability of different groups?

# Materials and methods

The study used multiple data sources to examine the socioeconomic features of census tracts including the cloud-free 30-m-resolution Landsat 8 satellite from the United States Geological Survey (USGS), surface temperature (APPEARS), and 5-year estimate American Community Survey (ACS) provided by the US Census Bureau (<https://www.census.gov/>) or Tidy census.

The study employs spatial regression analysis to investigate the relationship between heat risk—measured by land surface temperature—and the presence of racial minorities, low-income residents, and elderly populations. Additionally, the study identifies variations in spatial pattern variables among these vulnerable groups, categorizing them as low, medium, or high risk. Census tracts with a z-score greater than 1 are classified as “high risk,” those with a z-score lower than -1 are classified as “low risk,” while the remaining tracts are designated as “medium risk.” Subsequently, the study utilizes analysis of variance (ANOVA) to assess the significance of spatial pattern variations among these groups and examines how these disparities contribute to heat inequity.

#Load required packages:

```{r, message=F, warning=F}
library(tidyverse)
library(tidycensus)
library(leaflet)
library(dplyr)         # For data manipulation
library(tidyverse)
library(terra)
library(sf)
library(leaflet)        # For interactive maps
library(ggplot2)        # For ggplot2 plotting
library(rasterVis)      # For raster visualization
```

## Download, clean, and process data (Landsat 8 collective 2 level 1)

```{r}

# Load Erie County shapefile (adjust path as necessary)
erie_shapefile <- "data/erie.shp"
erie_county <- st_read(erie_shapefile)

# Load Landsat 8 raster files (adjust directory as necessary)
tif_files <- list.files("data", pattern = "\\.TIF$", full.names = TRUE)

# Load the rasters using terra::rast
rasters <- lapply(tif_files, rast)

# Check the extents, resolutions, and CRS of each raster
extents <- lapply(rasters, ext)
resolutions <- lapply(rasters, res)
crs_list <- lapply(rasters, crs)

# Find the common extent by intersecting the extents of all rasters
common_extent <- Reduce(intersect, extents)  # Finds the common extent

# Print the common extent
print(common_extent)

# Find the common resolution (assume the first raster resolution)
common_res <- res(rasters[[1]])

# Ensure the same CRS for all rasters
reference_crs <- crs(rasters[[1]])
rasters <- lapply(rasters, function(r) {
  if (!identical(crs(r), reference_crs)) {
    project(r, reference_crs)
  } else {
    r
  }
})

# Crop and resample the rasters to the common extent and resolution
rasters_aligned <- lapply(rasters, function(r) {
  r_resampled <- resample(crop(r, common_extent), rast(extent = common_extent, res = common_res, crs = reference_crs))
  return(r_resampled)
})

# Create a raster stack from the aligned rasters
raster_stack <- rast(rasters_aligned)

# Ensure the boundary is in the same CRS as the raster stack
if (crs(raster_stack) != st_crs(erie_county)) {
  erie_county <- st_transform(erie_county, crs(raster_stack))
}

# Convert the Erie County boundary shapefile to a 'SpatVector' for raster operations
erie_boundary_vect <- vect(erie_county)

# Crop the raster stack using the Erie County boundary
raster_cropped <- crop(raster_stack, erie_boundary_vect)

# Plot the cropped raster (first 12 bands)
plot(raster_cropped[[1:12]], main = "First 12 Bands of the Cropped Raster")

# Compute the mean temperature across the first 12 bands of the raster stack
temperature_stack <- raster_cropped[[1:12]]
mean_temperature <- app(temperature_stack, fun = mean, na.rm = TRUE)

# Plot the mean temperature
plot(mean_temperature, main = "Mean Temperature (First 12 Bands)")

# Ensure the CRS of the mean temperature raster matches the Erie County shapefile
if (crs(mean_temperature) != st_crs(erie_county)) {
  erie_county <- st_transform(erie_county, crs(mean_temperature))
}
```

```{r}

#Plot temperature intensity using color intensity from raster_cropped

plotRGB(raster_stack, stretch="lin")
plotRGB(raster_cropped, stretch="lin") # Linear stretch


plotRGB(raster_stack, stretch="hist")
plotRGB(raster_cropped, stretch="hist") # Histogram equalization stretch

```


```{r}
# Define a color palette for the temperature plot
temperature_palette <- terrain.colors(100)

# Plot the mean temperature with the Erie County boundary overlay
plot(mean_temperature, col = temperature_palette, main = "Mean Surface Temperature in Erie County, NY")
```




```{r}
# Perform hotspot analysis based on the 90th percentile of temperature values
# Calculate the 90th percentile of the temperature values
temperature_values <- values(mean_temperature)
percentile_90 <- quantile(temperature_values, 0.90, na.rm = TRUE)

# Create a binary hotspot layer: 1 for pixels above the 90th percentile, 0 otherwise
hotspot_layer <- mean_temperature >= percentile_90

# Plot the hotspot layer
plot(hotspot_layer, main = "Surface Temperature Hotspots in Erie County")
```




```{r}
# Crop raster stack using Erie County boundary
raster_cropped <- crop(raster_stack, erie_boundary_vect)

# Extract required bands for indices
red <- raster_cropped[[4]]     # Band 4: Red
nir <- raster_cropped[[5]]     # Band 5: Near-Infrared (NIR)
swir1 <- raster_cropped[[6]]   # Band 6: Shortwave Infrared 1 (SWIR1)
tir <- raster_cropped[[10]]    # Band 10: Thermal Infrared (TIR)

# Calculate NDVI
ndvi <- (nir - red) / (nir + red)

# Calculate NDBI
ndbi <- (swir1 - nir) / (swir1 + nir)

# Calculate LST
radiance <- tir * 0.0003342 + 0.1  # Conversion to radiance (use constants from metadata)
kelvin_temp <- 1321.08 / log((774.89 / radiance) + 1)  # Convert radiance to temperature in Kelvin
lst <- kelvin_temp - 273.15  # Convert Kelvin to Celsius

# Calculate UHRI
uhri <- (lst + ndbi) - ndvi
```

```{r}

# Set up the 2x2 plot layout
par(mfrow = c(2, 2))

# Bright color palettes for each index
ndvi_palette <- colorRampPalette(c("red", "yellow", "green"))(100)
ndbi_palette <- colorRampPalette(c("white", "blue", "black"))(100)  # Example for NDBI
lst_palette <- colorRampPalette(c("white", "blue", "red"))(100)  # Example for LST
uhri_palette <- colorRampPalette(c("white", "orange", "purple"))(100)  # Example for UHRI

# Plot NDVI with bright colors
plot(ndvi, main = "NDVI", col = ndvi_palette, legend = TRUE)

# Plot NDBI with bright colors
plot(ndbi, main = "NDBI", col = ndbi_palette, legend = TRUE)

# Plot LST with bright colors
plot(lst, main = "LST (°C)", col = lst_palette, legend = TRUE)

# Plot UHRI with bright colors
plot(uhri, main = "UHRI", col = uhri_palette, legend = TRUE)


```

#Alternative colors
```{r}
# Set up color palettes
ndvi_palette <- colorRampPalette(c("#048C02", "#77DD77", "#B5E7A0", "#D6E9C6"))
ndbi_palette <- colorRampPalette(c("#F5F5F5", "#A9A9A9", "#696969", "#000000"))
lst_palette <- colorRampPalette(c("#FFCCCB", "#FF7F50", "#FF4500", "#B22222"))
uhri_palette <- colorRampPalette(c("#4575B4", "#91BFDB", "#FEE090", "#FC8D59", "#D73027"))

# Plot results
par(mfrow = c(2, 2))  # Arrange plots in 2x2 grid

# Plot NDVI
plot(ndvi, col = ndvi_palette(100), main = "NDVI", axes = FALSE)
box()

# Plot NDBI
plot(ndbi, col = ndbi_palette(100), main = "NDBI", axes = FALSE)
box()

# Plot LST
plot(lst, col = lst_palette(100), main = "LST (°C)", axes = FALSE)
box()

# Plot UHRI
plot(uhri, col = uhri_palette(100), main = "UHRI", axes = FALSE)
box()

```


##Prepare census data for socio-demographic characteristics
```{r}
install.packages("tigris")
library(tigris)
library(tidycensus)
census_api_key("677c6e6ec5f3c8621d7b139013d29cb61cf4dcdd")

#download block data
# Define the variables for race, age, and income
race_vars <- c(
  "Total Population" = "P1_001N",
  "White alone" = "P1_003N",
  "Black or African American alone" = "P1_004N",
  "American Indian and Alaska Native alone" = "P1_005N",
  "Asian alone" = "P1_006N",
  "Native Hawaiian and Other Pacific Islander alone" = "P1_007N",
  "Some Other Race alone" = "P1_008N",
  "Two or More Races" = "P1_009N"
)

age_vars <- c(
  "Total Population" = "P1_001N",
  "Under 5 years" = "P1_003N",
  "5 to 9 years" = "P1_004N",
  "10 to 14 years" = "P1_005N",
  "15 to 19 years" = "P1_006N",
  "20 to 24 years" = "P1_007N",
  "25 to 34 years" = "P1_008N",
  "35 to 44 years" = "P1_009N",
  "45 to 54 years" = "P1_010N",
  "55 to 64 years" = "P1_011N",
  "65 to 74 years" = "P1_012N",
  "75 to 84 years" = "P1_013N",
  "85 years and over" = "P1_014N"
)

income_vars <- c(
  "Total Households" = "B19001_001",
  "Less than $10,000" = "B19001_002",
  "$10,000 to $14,999" = "B19001_003",
  "$15,000 to $19,999" = "B19001_004",
  "$20,000 to $24,999" = "B19001_005",
  "$25,000 to $29,999" = "B19001_006",
  "$30,000 to $34,999" = "B19001_007",
  "$35,000 to $39,999" = "B19001_008",
  "$40,000 to $44,999" = "B19001_009",
  "$45,000 to $49,999" = "B19001_010",
  "$50,000 to $59,999" = "B19001_011",
  "$60,000 to $74,999" = "B19001_012",
  "$75,000 to $99,999" = "B19001_013",
  "$100,000 to $124,999" = "B19001_014",
  "$125,000 to $149,999" = "B19001_015",
  "$150,000 to $199,999" = "B19001_016",
  "$200,000 or more" = "B19001_017"
)

# Fetch census data for race, age, and income
race_data <- get_decennial(
  geography = "block group",
  variables = race_vars,
  state = "NY", county = "Erie",
  year = 2020,
  geometry = TRUE
)

age_data <- get_decennial(
  geography = "block group",
  variables = age_vars,
  state = "NY", county = "Erie",
  year = 2020,
  geometry = TRUE
)

income_data <- get_acs(
  geography = "block group",
  variables = income_vars,
  state = "NY", county = "Erie",
  year = 2020,
  geometry = TRUE
)

```

#Join census data and shapefiles
```{r}

# Check the CRS of the Erie County shapefile and age data
st_crs(erie_county)  # CRS of the Erie County shapefile
st_crs(age_data)     # CRS of the age data

# If CRS do not match, transform 'age_data' to match the CRS of the Erie County shapefile
if (st_crs(erie_county) != st_crs(age_data)) {
  age_data <- st_transform(age_data, st_crs(erie_county))
}

# Perform the spatial join
age_merged <- st_join(erie_county, age_data, join = st_intersects)
```


```{r}

# Define color palettes
ndvi_palette <- colorRampPalette(c("red", "yellow", "green"))(100)
ndbi_palette <- colorRampPalette(c("white", "blue", "black"))(100)
lst_palette <- colorRampPalette(c("white", "blue", "red"))(100)
uhri_palette <- colorRampPalette(c("white", "orange", "purple"))(100)

# Ensure the CRS of `age_merged` and raster layers match (if not, transform `age_merged`)
# Check CRS of age_merged
st_crs(age_merged)  # This should match the CRS of your rasters

# If CRS is different, transform age_merged to match the raster CRS
age_merged <- st_transform(age_merged, crs = crs(ndvi))  # Replace `ndvi` with your raster object if needed

# Set up a 2x2 plot layout
par(mfrow = c(2, 2))

# Plot NDVI with bright colors
plot(ndvi, main = "NDVI", col = ndvi_palette, legend = TRUE)
plot(age_merged$geometry, add = TRUE, col = age_palette, border = "white")  # Overlay age_merged polygons

# Plot NDBI with bright colors
plot(ndbi, main = "NDBI", col = ndbi_palette, legend = TRUE)
plot(age_merged$geometry, add = TRUE, col = age_palette, border = "white")  # Overlay age_merged polygons

# Plot LST with bright colors
plot(lst, main = "LST (°C)", col = lst_palette, legend = TRUE)
plot(age_merged$geometry, add = TRUE, col = age_palette, border = "white")  # Overlay age_merged polygons

# Plot UHRI with bright colors
plot(uhri, main = "UHRI", col = uhri_palette, legend = TRUE)
plot(age_merged$geometry, add = TRUE, col = age_palette, border = "white")  # Overlay age_merged polygons

```



# Results

Tables and figures (maps and other graphics) are carefully planned to convey the results of your analysis. Intense exploration and evidence of many trials and failures. The author looked at the data in many different ways before coming to the final presentation of the data.

Show tables, plots, etc. and describe them.

```{r, fig.width=6, fig.height=3, fig.cap="Map of completely random data"}

# Downsample the cropped raster by a factor of 4 (adjust based on your needs)
ndvi_cropped_resampled <- aggregate(ndvi_cropped, fact = 4)

# Use the downsampled raster in the map
ndvi_map <- leaflet() %>%
  addTiles() %>%
  addRasterImage(ndvi_resampled, colors = ndvi_palette, opacity = 0.7, group = "NDVI") %>%
  addLegend(position = "topright", 
            pal = colorNumeric(palette = ndvi_palette, domain = values(ndvi_resampled)), 
            values = values(ndvi_resampled), 
            title = "NDVI") 
# Display the map
ndvi_map

```

```{r, fig.width=6, fig.height=3, fig.cap="Map of completely random data"}
ndbi_map<- leaflet() %>%
  addTiles() %>%
addRasterImage(ndbi_resampled, colors = ndbi_palette, opacity = 0.7, group = "NDBI") %>%
  addLegend(position = "topright", 
            pal = colorNumeric(palette = ndbi_palette, domain = values(ndbi_resampled)), 
            values = values(ndbi_resampled), 
            title = "NDBI")
#Display
ndbi_map

```


```{r, fig.width=6, fig.height=3, fig.cap="Map of completely random data"}
lst_map<- leaflet() %>%
  addTiles() %>%
  addRasterImage(lst_resampled, colors =
                   lst_palette, opacity = 0.7, group = "LST (°C)") %>%
  addLegend(position = "topright", 
            pal = colorNumeric(palette = lst_palette, domain = values(lst_resampled)), 
            values = values(lst_resampled), 
            title = "LST (°C)")
#Display map
lst_map
```


```{r}
 uhri <- leaflet() %>%
  addTiles() %>%addRasterImage(uhri_resampled, colors = uhri_palette, opacity = 0.7, group = "UHRI") %>%
  addLegend(position = "topright", 
            pal = colorNumeric(palette = uhri_palette, domain = values(uhri_resampled)), 
            values = values(uhri_resampled), 
            title = "UHRI") %>%
  addLayersControl(
    overlayGroups = c("NDVI", "NDBI", "LST (°C)", "UHRI"),
    options = layersControlOptions(collapsed = FALSE)
  )
#display
uhri
```



# Conclusions

Clear summary adequately describing the results and putting them in context. Discussion of further questions and ways to continue investigation.

# References

All sources are cited in a consistent manner
